(* Generated by ocaml-tree-sitter. *)
(*
   hcl grammar

   entrypoint: source_file
*)

open! Sexplib.Conv
open Tree_sitter_run

type escape_sequence = Token.t
[@@deriving sexp_of]

type identifier = Token.t
[@@deriving sexp_of]

type anon_choice_COMMA_30f2cfc = [
    `COMMA of Token.t (* "," *)
  | `Choice_LF of [ `LF of Token.t (* "\n" *) ]
]
[@@deriving sexp_of]

type heredoc = Token.t
[@@deriving sexp_of]

type numeric_literal = Token.t
[@@deriving sexp_of]

type quoted_template = (
    Token.t (* "\"" *)
  * [ `Blank of unit (* blank *) | `Esc_seq of escape_sequence (*tok*) ]
      list (* zero or more *)
  * Token.t (* "\"" *)
)
[@@deriving sexp_of]

type literal_value = [
    `Nume_lit of numeric_literal (*tok*)
  | `True of Token.t (* "true" *)
  | `False of Token.t (* "false" *)
  | `Null of Token.t (* "null" *)
]
[@@deriving sexp_of]

type string_literal = quoted_template
[@@deriving sexp_of]

type get_attr = (Token.t (* "." *) * identifier (*tok*))
[@@deriving sexp_of]

type template_expr = [
    `Quoted_temp of string_literal
  | `Here of heredoc (*tok*)
]
[@@deriving sexp_of]

type anon_choice_str_lit_9b73c1d = [
    `Str_lit of string_literal
  | `Id of identifier (*tok*)
]
[@@deriving sexp_of]

type binary_op = [
    `Exp_choice_STAR_exp of (
        expression
      * [
            `STAR of Token.t (* "*" *)
          | `SLASH of Token.t (* "/" *)
          | `PERC of Token.t (* "%" *)
        ]
      * expression
    )
  | `Exp_choice_PLUS_exp of (
        expression
      * [ `PLUS of Token.t (* "+" *) | `DASH of Token.t (* "-" *) ]
      * expression
    )
  | `Exp_choice_GT_exp of (
        expression
      * [
            `GT of Token.t (* ">" *)
          | `GTEQ of Token.t (* ">=" *)
          | `LT of Token.t (* "<" *)
          | `LTEQ of Token.t (* "<=" *)
        ]
      * expression
    )
  | `Exp_choice_EQEQ_exp of (
        expression
      * [ `EQEQ of Token.t (* "==" *) | `BANGEQ of Token.t (* "!=" *) ]
      * expression
    )
  | `Exp_AMPAMP_exp of (expression * Token.t (* "&&" *) * expression)
  | `Exp_BARBAR_exp of (expression * Token.t (* "||" *) * expression)
]

and collection_value = [
    `Tuple of (
        Token.t (* "[" *)
      * (
            expression
          * (Token.t (* "," *) * expression) list (* zero or more *)
          * Token.t (* "," *) option
        )
          option
      * Token.t (* "]" *)
    )
  | `Obj of (
        Token.t (* "{" *)
      * (
            object_elem
          * (anon_choice_COMMA_30f2cfc * object_elem) list (* zero or more *)
          * anon_choice_COMMA_30f2cfc option
        )
          option
      * Token.t (* "}" *)
    )
]

and expr_term = [
    `Lit_value of literal_value
  | `Coll_value of collection_value
  | `Temp_expr of template_expr
  | `Var_expr of identifier (*tok*)
  | `Func_call of (
        identifier (*tok*)
      * Token.t (* "(" *)
      * (
            expression
          * (Token.t (* "," *) * expression) list (* zero or more *)
          * [
                `COMMA of Token.t (* "," *)
              | `DOTDOTDOT of Token.t (* "..." *)
            ]
              option
        )
          option
      * Token.t (* ")" *)
    )
  | `For_expr of for_expr
  | `Expr_term_index of (expr_term * index)
  | `Expr_term_get_attr of (expr_term * get_attr)
  | `Expr_term_splat of (expr_term * splat)
  | `LPAR_exp_RPAR of (Token.t (* "(" *) * expression * Token.t (* ")" *))
]

and expression = [
    `Expr_term of expr_term
  | `Oper of operation
  | `Cond of (
        expression * Token.t (* "?" *) * expression * Token.t (* ":" *)
      * expression
    )
]

and for_cond = (Token.t (* "if" *) * expression)

and for_expr = [
    `For_tuple of (
        Token.t (* "[" *)
      * for_intro
      * expression
      * for_cond option
      * Token.t (* "]" *)
    )
  | `For_obj of (
        Token.t (* "{" *)
      * for_intro
      * expression
      * Token.t (* "=>" *)
      * expression
      * Token.t (* "..." *) option
      * for_cond option
      * Token.t (* "}" *)
    )
]

and for_intro = (
    Token.t (* "for" *)
  * identifier (*tok*)
  * (Token.t (* "," *) * identifier (*tok*)) option
  * Token.t (* "in" *)
  * expression
  * Token.t (* ":" *)
)

and index = (Token.t (* "[" *) * expression * Token.t (* "]" *))

and object_elem = (
    [ `Id of identifier (*tok*) | `Exp of expression ]
  * [ `EQ of Token.t (* "=" *) | `COLON of Token.t (* ":" *) ]
  * expression
)

and operation = [
    `Un_op of (
        [ `DASH of Token.t (* "-" *) | `BANG of Token.t (* "!" *) ]
      * expr_term
    )
  | `Bin_op of binary_op
]

and splat = [
    `Splat_attr of (
        Token.t (* "." *)
      * Token.t (* "*" *)
      * get_attr list (* zero or more *)
    )
  | `Splat_full of (
        Token.t (* "[" *)
      * Token.t (* "*" *)
      * Token.t (* "]" *)
      * [ `Get_attr of get_attr | `Index of index ] list (* zero or more *)
    )
]
[@@deriving sexp_of]

type one_line_block = (
    identifier (*tok*)
  * anon_choice_str_lit_9b73c1d list (* zero or more *)
  * Token.t (* "{" *)
  * (identifier (*tok*) * Token.t (* "=" *) * expression) option
  * Token.t (* "}" *)
  * [ `LF of Token.t (* "\n" *) ]
)
[@@deriving sexp_of]

type attribute = (
    identifier (*tok*)
  * Token.t (* "=" *)
  * expression
  * [ `LF of Token.t (* "\n" *) ]
)
[@@deriving sexp_of]

type block = (
    identifier (*tok*)
  * anon_choice_str_lit_9b73c1d list (* zero or more *)
  * Token.t (* "{" *)
  * [ `LF of Token.t (* "\n" *) ]
  * source_file option
  * Token.t (* "}" *)
  * [ `LF of Token.t (* "\n" *) ]
)

and body =
  [ `Attr of attribute | `Blk of block | `One_line_blk of one_line_block ]
    list (* one or more *)

and source_file = body
[@@deriving sexp_of]

type true_ (* inlined *) = Token.t (* "true" *)
[@@deriving sexp_of]

type comment (* inlined *) = Token.t
[@@deriving sexp_of]

type null (* inlined *) = Token.t (* "null" *)
[@@deriving sexp_of]

type false_ (* inlined *) = Token.t (* "false" *)
[@@deriving sexp_of]

type variable_expr (* inlined *) = identifier (*tok*)
[@@deriving sexp_of]

type splat_attr (* inlined *) = (
    Token.t (* "." *)
  * Token.t (* "*" *)
  * get_attr list (* zero or more *)
)
[@@deriving sexp_of]

type conditional (* inlined *) = (
    expression * Token.t (* "?" *) * expression * Token.t (* ":" *)
  * expression
)
[@@deriving sexp_of]

type for_object (* inlined *) = (
    Token.t (* "{" *)
  * for_intro
  * expression
  * Token.t (* "=>" *)
  * expression
  * Token.t (* "..." *) option
  * for_cond option
  * Token.t (* "}" *)
)
[@@deriving sexp_of]

type for_tuple (* inlined *) = (
    Token.t (* "[" *)
  * for_intro
  * expression
  * for_cond option
  * Token.t (* "]" *)
)
[@@deriving sexp_of]

type function_call (* inlined *) = (
    identifier (*tok*)
  * Token.t (* "(" *)
  * (
        expression
      * (Token.t (* "," *) * expression) list (* zero or more *)
      * [ `COMMA of Token.t (* "," *) | `DOTDOTDOT of Token.t (* "..." *) ]
          option
    )
      option
  * Token.t (* ")" *)
)
[@@deriving sexp_of]

type object_ (* inlined *) = (
    Token.t (* "{" *)
  * (
        object_elem
      * (anon_choice_COMMA_30f2cfc * object_elem) list (* zero or more *)
      * anon_choice_COMMA_30f2cfc option
    )
      option
  * Token.t (* "}" *)
)
[@@deriving sexp_of]

type splat_full (* inlined *) = (
    Token.t (* "[" *)
  * Token.t (* "*" *)
  * Token.t (* "]" *)
  * [ `Get_attr of get_attr | `Index of index ] list (* zero or more *)
)
[@@deriving sexp_of]

type tuple (* inlined *) = (
    Token.t (* "[" *)
  * (
        expression
      * (Token.t (* "," *) * expression) list (* zero or more *)
      * Token.t (* "," *) option
    )
      option
  * Token.t (* "]" *)
)
[@@deriving sexp_of]

type unary_op (* inlined *) = (
    [ `DASH of Token.t (* "-" *) | `BANG of Token.t (* "!" *) ]
  * expr_term
)
[@@deriving sexp_of]

let dump_tree root =
  sexp_of_source_file root
  |> Print_sexp.to_stdout
