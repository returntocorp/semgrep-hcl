(* Generated by ocaml-tree-sitter. *)

(*
   Disable warning 42:
     "this use of Foo relies on type-directed disambiguation,
     it will not compile with OCaml 4.00 or earlier."
*)
[@@@warning "-42"]

(* Disable warnings against unused variables. *)
[@@@warning "-26-27-32"]

open Tree_sitter_bindings
open Tree_sitter_run

let debug = ref false

type mt = Run.matcher_token

external create_parser :
  unit -> Tree_sitter_API.ts_parser = "octs_create_parser_hcl"

let ts_parser = create_parser ()

let parse_source_string ?src_file contents =
  Tree_sitter_parsing.parse_source_string ?src_file ts_parser contents

let parse_source_file src_file =
  Tree_sitter_parsing.parse_source_file ts_parser src_file

let extras = [
  "comment";
]

let children_regexps : (string * Run.exp option) list = [
  "true", None;
  "escape_sequence", None;
  "false", None;
  "null", None;
  "numeric_literal", None;
  "heredoc", None;
  "identifier", None;
  "quoted_template",
  Some (
    Seq [
      Token (Literal "\"");
      Repeat (
        Alt [|
          Nothing;
          Token (Name "escape_sequence");
        |];
      );
      Token (Literal "\"");
    ];
  );
  "literal_value",
  Some (
    Alt [|
      Token (Name "numeric_literal");
      Token (Name "true");
      Token (Name "false");
      Token (Name "null");
    |];
  );
  "variable_expr", Some (Token (Name "identifier"););
  "get_attr",
  Some (
    Seq [
      Token (Literal ".");
      Token (Name "identifier");
    ];
  );
  "template_expr",
  Some (
    Alt [|
      Token (Name "quoted_template");
      Token (Name "heredoc");
    |];
  );
  "string_literal", Some (Token (Name "quoted_template"););
  "splat_attr",
  Some (
    Seq [
      Token (Literal ".");
      Token (Literal "*");
      Repeat (
        Token (Name "get_attr");
      );
    ];
  );
  "binary_op",
  Some (
    Alt [|
      Seq [
        Token (Name "expression");
        Alt [|
          Token (Literal "*");
          Token (Literal "/");
          Token (Literal "%");
        |];
        Token (Name "expression");
      ];
      Seq [
        Token (Name "expression");
        Alt [|
          Token (Literal "+");
          Token (Literal "-");
        |];
        Token (Name "expression");
      ];
      Seq [
        Token (Name "expression");
        Alt [|
          Token (Literal ">");
          Token (Literal ">=");
          Token (Literal "<");
          Token (Literal "<=");
        |];
        Token (Name "expression");
      ];
      Seq [
        Token (Name "expression");
        Alt [|
          Token (Literal "==");
          Token (Literal "!=");
        |];
        Token (Name "expression");
      ];
      Seq [
        Token (Name "expression");
        Token (Literal "&&");
        Token (Name "expression");
      ];
      Seq [
        Token (Name "expression");
        Token (Literal "||");
        Token (Name "expression");
      ];
    |];
  );
  "collection_value",
  Some (
    Alt [|
      Token (Name "tuple");
      Token (Name "object");
    |];
  );
  "conditional",
  Some (
    Seq [
      Token (Name "expression");
      Token (Literal "?");
      Token (Name "expression");
      Token (Literal ":");
      Token (Name "expression");
    ];
  );
  "expr_term",
  Some (
    Alt [|
      Token (Name "literal_value");
      Token (Name "collection_value");
      Token (Name "template_expr");
      Token (Name "variable_expr");
      Token (Name "function_call");
      Token (Name "for_expr");
      Seq [
        Token (Name "expr_term");
        Token (Name "index");
      ];
      Seq [
        Token (Name "expr_term");
        Token (Name "get_attr");
      ];
      Seq [
        Token (Name "expr_term");
        Token (Name "splat");
      ];
      Seq [
        Token (Literal "(");
        Token (Name "expression");
        Token (Literal ")");
      ];
    |];
  );
  "expression",
  Some (
    Alt [|
      Token (Name "expr_term");
      Token (Name "operation");
      Token (Name "conditional");
    |];
  );
  "for_cond",
  Some (
    Seq [
      Token (Literal "if");
      Token (Name "expression");
    ];
  );
  "for_expr",
  Some (
    Alt [|
      Token (Name "for_tuple");
      Token (Name "for_object");
    |];
  );
  "for_intro",
  Some (
    Seq [
      Token (Literal "for");
      Token (Name "identifier");
      Opt (
        Seq [
          Token (Literal ",");
          Token (Name "identifier");
        ];
      );
      Token (Literal "in");
      Token (Name "expression");
      Token (Literal ":");
    ];
  );
  "for_object",
  Some (
    Seq [
      Token (Literal "{");
      Token (Name "for_intro");
      Token (Name "expression");
      Token (Literal "=>");
      Token (Name "expression");
      Opt (
        Token (Literal "...");
      );
      Opt (
        Token (Name "for_cond");
      );
      Token (Literal "}");
    ];
  );
  "for_tuple",
  Some (
    Seq [
      Token (Literal "[");
      Token (Name "for_intro");
      Token (Name "expression");
      Opt (
        Token (Name "for_cond");
      );
      Token (Literal "]");
    ];
  );
  "function_call",
  Some (
    Seq [
      Token (Name "identifier");
      Token (Literal "(");
      Opt (
        Seq [
          Token (Name "expression");
          Repeat (
            Seq [
              Token (Literal ",");
              Token (Name "expression");
            ];
          );
          Opt (
            Alt [|
              Token (Literal ",");
              Token (Literal "...");
            |];
          );
        ];
      );
      Token (Literal ")");
    ];
  );
  "index",
  Some (
    Seq [
      Token (Literal "[");
      Token (Name "expression");
      Token (Literal "]");
    ];
  );
  "object",
  Some (
    Seq [
      Token (Literal "{");
      Opt (
        Seq [
          Token (Name "object_elem");
          Repeat (
            Seq [
              Alt [|
                Token (Literal ",");
                Alt [|
                  Token (Literal "\n");
                |];
              |];
              Token (Name "object_elem");
            ];
          );
          Opt (
            Alt [|
              Token (Literal ",");
              Alt [|
                Token (Literal "\n");
              |];
            |];
          );
        ];
      );
      Token (Literal "}");
    ];
  );
  "object_elem",
  Some (
    Seq [
      Alt [|
        Token (Name "identifier");
        Token (Name "expression");
      |];
      Alt [|
        Token (Literal "=");
        Token (Literal ":");
      |];
      Token (Name "expression");
    ];
  );
  "operation",
  Some (
    Alt [|
      Token (Name "unary_op");
      Token (Name "binary_op");
    |];
  );
  "splat",
  Some (
    Alt [|
      Token (Name "splat_attr");
      Token (Name "splat_full");
    |];
  );
  "splat_full",
  Some (
    Seq [
      Token (Literal "[");
      Token (Literal "*");
      Token (Literal "]");
      Repeat (
        Alt [|
          Token (Name "get_attr");
          Token (Name "index");
        |];
      );
    ];
  );
  "tuple",
  Some (
    Seq [
      Token (Literal "[");
      Opt (
        Seq [
          Token (Name "expression");
          Repeat (
            Seq [
              Token (Literal ",");
              Token (Name "expression");
            ];
          );
          Opt (
            Token (Literal ",");
          );
        ];
      );
      Token (Literal "]");
    ];
  );
  "unary_op",
  Some (
    Seq [
      Alt [|
        Token (Literal "-");
        Token (Literal "!");
      |];
      Token (Name "expr_term");
    ];
  );
  "attribute",
  Some (
    Seq [
      Token (Name "identifier");
      Token (Literal "=");
      Token (Name "expression");
      Alt [|
        Token (Literal "\n");
      |];
    ];
  );
  "one_line_block",
  Some (
    Seq [
      Token (Name "identifier");
      Repeat (
        Alt [|
          Token (Name "string_literal");
          Token (Name "identifier");
        |];
      );
      Token (Literal "{");
      Opt (
        Seq [
          Token (Name "identifier");
          Token (Literal "=");
          Token (Name "expression");
        ];
      );
      Token (Literal "}");
      Alt [|
        Token (Literal "\n");
      |];
    ];
  );
  "block",
  Some (
    Seq [
      Token (Name "identifier");
      Repeat (
        Alt [|
          Token (Name "string_literal");
          Token (Name "identifier");
        |];
      );
      Token (Literal "{");
      Alt [|
        Token (Literal "\n");
      |];
      Opt (
        Token (Name "body");
      );
      Token (Literal "}");
      Alt [|
        Token (Literal "\n");
      |];
    ];
  );
  "body",
  Some (
    Repeat1 (
      Alt [|
        Token (Name "attribute");
        Token (Name "block");
        Token (Name "one_line_block");
      |];
    );
  );
  "source_file", Some (Token (Name "body"););
]

let trans_true_ ((kind, body) : mt) : CST.true_ =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_escape_sequence ((kind, body) : mt) : CST.escape_sequence =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_false_ ((kind, body) : mt) : CST.false_ =
  match body with
  | Leaf v -> v
  | Children _ -> assert false


let trans_null ((kind, body) : mt) : CST.null =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_numeric_literal ((kind, body) : mt) : CST.numeric_literal =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_heredoc ((kind, body) : mt) : CST.heredoc =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_identifier ((kind, body) : mt) : CST.identifier =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_quoted_template ((kind, body) : mt) : CST.quoted_template =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2] ->
          (
            Run.trans_token (Run.matcher_token v0),
            Run.repeat
              (fun v ->
                (match v with
                | Alt (0, v) ->
                    `Blank (
                      Run.nothing v
                    )
                | Alt (1, v) ->
                    `Esc_seq (
                      trans_escape_sequence (Run.matcher_token v)
                    )
                | _ -> assert false
                )
              )
              v1
            ,
            Run.trans_token (Run.matcher_token v2)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_literal_value ((kind, body) : mt) : CST.literal_value =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `Nume_lit (
            trans_numeric_literal (Run.matcher_token v)
          )
      | Alt (1, v) ->
          `True (
            trans_true_ (Run.matcher_token v)
          )
      | Alt (2, v) ->
          `False (
            trans_false_ (Run.matcher_token v)
          )
      | Alt (3, v) ->
          `Null (
            trans_null (Run.matcher_token v)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_variable_expr ((kind, body) : mt) : CST.variable_expr =
  match body with
  | Children v ->
      trans_identifier (Run.matcher_token v)
  | Leaf _ -> assert false

let trans_get_attr ((kind, body) : mt) : CST.get_attr =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1] ->
          (
            Run.trans_token (Run.matcher_token v0),
            trans_identifier (Run.matcher_token v1)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_template_expr ((kind, body) : mt) : CST.template_expr =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `Quoted_temp (
            trans_quoted_template (Run.matcher_token v)
          )
      | Alt (1, v) ->
          `Here (
            trans_heredoc (Run.matcher_token v)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_string_literal ((kind, body) : mt) : CST.string_literal =
  match body with
  | Children v ->
      trans_quoted_template (Run.matcher_token v)
  | Leaf _ -> assert false

let trans_splat_attr ((kind, body) : mt) : CST.splat_attr =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2] ->
          (
            Run.trans_token (Run.matcher_token v0),
            Run.trans_token (Run.matcher_token v1),
            Run.repeat
              (fun v -> trans_get_attr (Run.matcher_token v))
              v2
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let rec trans_binary_op ((kind, body) : mt) : CST.binary_op =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `Exp_choice_STAR_exp (
            (match v with
            | Seq [v0; v1; v2] ->
                (
                  trans_expression (Run.matcher_token v0),
                  (match v1 with
                  | Alt (0, v) ->
                      `STAR (
                        Run.trans_token (Run.matcher_token v)
                      )
                  | Alt (1, v) ->
                      `SLASH (
                        Run.trans_token (Run.matcher_token v)
                      )
                  | Alt (2, v) ->
                      `PERC (
                        Run.trans_token (Run.matcher_token v)
                      )
                  | _ -> assert false
                  )
                  ,
                  trans_expression (Run.matcher_token v2)
                )
            | _ -> assert false
            )
          )
      | Alt (1, v) ->
          `Exp_choice_PLUS_exp (
            (match v with
            | Seq [v0; v1; v2] ->
                (
                  trans_expression (Run.matcher_token v0),
                  (match v1 with
                  | Alt (0, v) ->
                      `PLUS (
                        Run.trans_token (Run.matcher_token v)
                      )
                  | Alt (1, v) ->
                      `DASH (
                        Run.trans_token (Run.matcher_token v)
                      )
                  | _ -> assert false
                  )
                  ,
                  trans_expression (Run.matcher_token v2)
                )
            | _ -> assert false
            )
          )
      | Alt (2, v) ->
          `Exp_choice_GT_exp (
            (match v with
            | Seq [v0; v1; v2] ->
                (
                  trans_expression (Run.matcher_token v0),
                  (match v1 with
                  | Alt (0, v) ->
                      `GT (
                        Run.trans_token (Run.matcher_token v)
                      )
                  | Alt (1, v) ->
                      `GTEQ (
                        Run.trans_token (Run.matcher_token v)
                      )
                  | Alt (2, v) ->
                      `LT (
                        Run.trans_token (Run.matcher_token v)
                      )
                  | Alt (3, v) ->
                      `LTEQ (
                        Run.trans_token (Run.matcher_token v)
                      )
                  | _ -> assert false
                  )
                  ,
                  trans_expression (Run.matcher_token v2)
                )
            | _ -> assert false
            )
          )
      | Alt (3, v) ->
          `Exp_choice_EQEQ_exp (
            (match v with
            | Seq [v0; v1; v2] ->
                (
                  trans_expression (Run.matcher_token v0),
                  (match v1 with
                  | Alt (0, v) ->
                      `EQEQ (
                        Run.trans_token (Run.matcher_token v)
                      )
                  | Alt (1, v) ->
                      `BANGEQ (
                        Run.trans_token (Run.matcher_token v)
                      )
                  | _ -> assert false
                  )
                  ,
                  trans_expression (Run.matcher_token v2)
                )
            | _ -> assert false
            )
          )
      | Alt (4, v) ->
          `Exp_AMPAMP_exp (
            (match v with
            | Seq [v0; v1; v2] ->
                (
                  trans_expression (Run.matcher_token v0),
                  Run.trans_token (Run.matcher_token v1),
                  trans_expression (Run.matcher_token v2)
                )
            | _ -> assert false
            )
          )
      | Alt (5, v) ->
          `Exp_BARBAR_exp (
            (match v with
            | Seq [v0; v1; v2] ->
                (
                  trans_expression (Run.matcher_token v0),
                  Run.trans_token (Run.matcher_token v1),
                  trans_expression (Run.matcher_token v2)
                )
            | _ -> assert false
            )
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_collection_value ((kind, body) : mt) : CST.collection_value =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `Tuple (
            trans_tuple (Run.matcher_token v)
          )
      | Alt (1, v) ->
          `Obj (
            trans_object_ (Run.matcher_token v)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_conditional ((kind, body) : mt) : CST.conditional =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3; v4] ->
          (
            trans_expression (Run.matcher_token v0),
            Run.trans_token (Run.matcher_token v1),
            trans_expression (Run.matcher_token v2),
            Run.trans_token (Run.matcher_token v3),
            trans_expression (Run.matcher_token v4)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_expr_term ((kind, body) : mt) : CST.expr_term =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `Lit_value (
            trans_literal_value (Run.matcher_token v)
          )
      | Alt (1, v) ->
          `Coll_value (
            trans_collection_value (Run.matcher_token v)
          )
      | Alt (2, v) ->
          `Temp_expr (
            trans_template_expr (Run.matcher_token v)
          )
      | Alt (3, v) ->
          `Var_expr (
            trans_variable_expr (Run.matcher_token v)
          )
      | Alt (4, v) ->
          `Func_call (
            trans_function_call (Run.matcher_token v)
          )
      | Alt (5, v) ->
          `For_expr (
            trans_for_expr (Run.matcher_token v)
          )
      | Alt (6, v) ->
          `Expr_term_index (
            (match v with
            | Seq [v0; v1] ->
                (
                  trans_expr_term (Run.matcher_token v0),
                  trans_index (Run.matcher_token v1)
                )
            | _ -> assert false
            )
          )
      | Alt (7, v) ->
          `Expr_term_get_attr (
            (match v with
            | Seq [v0; v1] ->
                (
                  trans_expr_term (Run.matcher_token v0),
                  trans_get_attr (Run.matcher_token v1)
                )
            | _ -> assert false
            )
          )
      | Alt (8, v) ->
          `Expr_term_splat (
            (match v with
            | Seq [v0; v1] ->
                (
                  trans_expr_term (Run.matcher_token v0),
                  trans_splat (Run.matcher_token v1)
                )
            | _ -> assert false
            )
          )
      | Alt (9, v) ->
          `LPAR_exp_RPAR (
            (match v with
            | Seq [v0; v1; v2] ->
                (
                  Run.trans_token (Run.matcher_token v0),
                  trans_expression (Run.matcher_token v1),
                  Run.trans_token (Run.matcher_token v2)
                )
            | _ -> assert false
            )
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_expression ((kind, body) : mt) : CST.expression =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `Expr_term (
            trans_expr_term (Run.matcher_token v)
          )
      | Alt (1, v) ->
          `Oper (
            trans_operation (Run.matcher_token v)
          )
      | Alt (2, v) ->
          `Cond (
            trans_conditional (Run.matcher_token v)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_for_cond ((kind, body) : mt) : CST.for_cond =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1] ->
          (
            Run.trans_token (Run.matcher_token v0),
            trans_expression (Run.matcher_token v1)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_for_expr ((kind, body) : mt) : CST.for_expr =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `For_tuple (
            trans_for_tuple (Run.matcher_token v)
          )
      | Alt (1, v) ->
          `For_obj (
            trans_for_object (Run.matcher_token v)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_for_intro ((kind, body) : mt) : CST.for_intro =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3; v4; v5] ->
          (
            Run.trans_token (Run.matcher_token v0),
            trans_identifier (Run.matcher_token v1),
            Run.opt
              (fun v ->
                (match v with
                | Seq [v0; v1] ->
                    (
                      Run.trans_token (Run.matcher_token v0),
                      trans_identifier (Run.matcher_token v1)
                    )
                | _ -> assert false
                )
              )
              v2
            ,
            Run.trans_token (Run.matcher_token v3),
            trans_expression (Run.matcher_token v4),
            Run.trans_token (Run.matcher_token v5)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_for_object ((kind, body) : mt) : CST.for_object =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3; v4; v5; v6; v7] ->
          (
            Run.trans_token (Run.matcher_token v0),
            trans_for_intro (Run.matcher_token v1),
            trans_expression (Run.matcher_token v2),
            Run.trans_token (Run.matcher_token v3),
            trans_expression (Run.matcher_token v4),
            Run.opt
              (fun v -> Run.trans_token (Run.matcher_token v))
              v5
            ,
            Run.opt
              (fun v -> trans_for_cond (Run.matcher_token v))
              v6
            ,
            Run.trans_token (Run.matcher_token v7)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_for_tuple ((kind, body) : mt) : CST.for_tuple =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3; v4] ->
          (
            Run.trans_token (Run.matcher_token v0),
            trans_for_intro (Run.matcher_token v1),
            trans_expression (Run.matcher_token v2),
            Run.opt
              (fun v -> trans_for_cond (Run.matcher_token v))
              v3
            ,
            Run.trans_token (Run.matcher_token v4)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_function_call ((kind, body) : mt) : CST.function_call =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3] ->
          (
            trans_identifier (Run.matcher_token v0),
            Run.trans_token (Run.matcher_token v1),
            Run.opt
              (fun v ->
                (match v with
                | Seq [v0; v1; v2] ->
                    (
                      trans_expression (Run.matcher_token v0),
                      Run.repeat
                        (fun v ->
                          (match v with
                          | Seq [v0; v1] ->
                              (
                                Run.trans_token (Run.matcher_token v0),
                                trans_expression (Run.matcher_token v1)
                              )
                          | _ -> assert false
                          )
                        )
                        v1
                      ,
                      Run.opt
                        (fun v ->
                          (match v with
                          | Alt (0, v) ->
                              `COMMA (
                                Run.trans_token (Run.matcher_token v)
                              )
                          | Alt (1, v) ->
                              `DOTDOTDOT (
                                Run.trans_token (Run.matcher_token v)
                              )
                          | _ -> assert false
                          )
                        )
                        v2
                    )
                | _ -> assert false
                )
              )
              v2
            ,
            Run.trans_token (Run.matcher_token v3)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_index ((kind, body) : mt) : CST.index =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2] ->
          (
            Run.trans_token (Run.matcher_token v0),
            trans_expression (Run.matcher_token v1),
            Run.trans_token (Run.matcher_token v2)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_object_ ((kind, body) : mt) : CST.object_ =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2] ->
          (
            Run.trans_token (Run.matcher_token v0),
            Run.opt
              (fun v ->
                (match v with
                | Seq [v0; v1; v2] ->
                    (
                      trans_object_elem (Run.matcher_token v0),
                      Run.repeat
                        (fun v ->
                          (match v with
                          | Seq [v0; v1] ->
                              (
                                (match v0 with
                                | Alt (0, v) ->
                                    `COMMA (
                                      Run.trans_token (Run.matcher_token v)
                                    )
                                | Alt (1, v) ->
                                    `Choice_LF (
                                      (match v with
                                      | Alt (0, v) ->
                                          `LF (
                                            Run.trans_token (Run.matcher_token v)
                                          )
                                      | _ -> assert false
                                      )
                                    )
                                | _ -> assert false
                                )
                                ,
                                trans_object_elem (Run.matcher_token v1)
                              )
                          | _ -> assert false
                          )
                        )
                        v1
                      ,
                      Run.opt
                        (fun v ->
                          (match v with
                          | Alt (0, v) ->
                              `COMMA (
                                Run.trans_token (Run.matcher_token v)
                              )
                          | Alt (1, v) ->
                              `Choice_LF (
                                (match v with
                                | Alt (0, v) ->
                                    `LF (
                                      Run.trans_token (Run.matcher_token v)
                                    )
                                | _ -> assert false
                                )
                              )
                          | _ -> assert false
                          )
                        )
                        v2
                    )
                | _ -> assert false
                )
              )
              v1
            ,
            Run.trans_token (Run.matcher_token v2)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_object_elem ((kind, body) : mt) : CST.object_elem =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2] ->
          (
            (match v0 with
            | Alt (0, v) ->
                `Id (
                  trans_identifier (Run.matcher_token v)
                )
            | Alt (1, v) ->
                `Exp (
                  trans_expression (Run.matcher_token v)
                )
            | _ -> assert false
            )
            ,
            (match v1 with
            | Alt (0, v) ->
                `EQ (
                  Run.trans_token (Run.matcher_token v)
                )
            | Alt (1, v) ->
                `COLON (
                  Run.trans_token (Run.matcher_token v)
                )
            | _ -> assert false
            )
            ,
            trans_expression (Run.matcher_token v2)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_operation ((kind, body) : mt) : CST.operation =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `Un_op (
            trans_unary_op (Run.matcher_token v)
          )
      | Alt (1, v) ->
          `Bin_op (
            trans_binary_op (Run.matcher_token v)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_splat ((kind, body) : mt) : CST.splat =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `Splat_attr (
            trans_splat_attr (Run.matcher_token v)
          )
      | Alt (1, v) ->
          `Splat_full (
            trans_splat_full (Run.matcher_token v)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_splat_full ((kind, body) : mt) : CST.splat_full =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3] ->
          (
            Run.trans_token (Run.matcher_token v0),
            Run.trans_token (Run.matcher_token v1),
            Run.trans_token (Run.matcher_token v2),
            Run.repeat
              (fun v ->
                (match v with
                | Alt (0, v) ->
                    `Get_attr (
                      trans_get_attr (Run.matcher_token v)
                    )
                | Alt (1, v) ->
                    `Index (
                      trans_index (Run.matcher_token v)
                    )
                | _ -> assert false
                )
              )
              v3
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_tuple ((kind, body) : mt) : CST.tuple =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2] ->
          (
            Run.trans_token (Run.matcher_token v0),
            Run.opt
              (fun v ->
                (match v with
                | Seq [v0; v1; v2] ->
                    (
                      trans_expression (Run.matcher_token v0),
                      Run.repeat
                        (fun v ->
                          (match v with
                          | Seq [v0; v1] ->
                              (
                                Run.trans_token (Run.matcher_token v0),
                                trans_expression (Run.matcher_token v1)
                              )
                          | _ -> assert false
                          )
                        )
                        v1
                      ,
                      Run.opt
                        (fun v -> Run.trans_token (Run.matcher_token v))
                        v2
                    )
                | _ -> assert false
                )
              )
              v1
            ,
            Run.trans_token (Run.matcher_token v2)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_unary_op ((kind, body) : mt) : CST.unary_op =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1] ->
          (
            (match v0 with
            | Alt (0, v) ->
                `DASH (
                  Run.trans_token (Run.matcher_token v)
                )
            | Alt (1, v) ->
                `BANG (
                  Run.trans_token (Run.matcher_token v)
                )
            | _ -> assert false
            )
            ,
            trans_expr_term (Run.matcher_token v1)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_attribute ((kind, body) : mt) : CST.attribute =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3] ->
          (
            trans_identifier (Run.matcher_token v0),
            Run.trans_token (Run.matcher_token v1),
            trans_expression (Run.matcher_token v2),
            (match v3 with
            | Alt (0, v) ->
                `LF (
                  Run.trans_token (Run.matcher_token v)
                )
            | _ -> assert false
            )
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_one_line_block ((kind, body) : mt) : CST.one_line_block =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3; v4; v5] ->
          (
            trans_identifier (Run.matcher_token v0),
            Run.repeat
              (fun v ->
                (match v with
                | Alt (0, v) ->
                    `Str_lit (
                      trans_string_literal (Run.matcher_token v)
                    )
                | Alt (1, v) ->
                    `Id (
                      trans_identifier (Run.matcher_token v)
                    )
                | _ -> assert false
                )
              )
              v1
            ,
            Run.trans_token (Run.matcher_token v2),
            Run.opt
              (fun v ->
                (match v with
                | Seq [v0; v1; v2] ->
                    (
                      trans_identifier (Run.matcher_token v0),
                      Run.trans_token (Run.matcher_token v1),
                      trans_expression (Run.matcher_token v2)
                    )
                | _ -> assert false
                )
              )
              v3
            ,
            Run.trans_token (Run.matcher_token v4),
            (match v5 with
            | Alt (0, v) ->
                `LF (
                  Run.trans_token (Run.matcher_token v)
                )
            | _ -> assert false
            )
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let rec trans_block ((kind, body) : mt) : CST.block =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3; v4; v5; v6] ->
          (
            trans_identifier (Run.matcher_token v0),
            Run.repeat
              (fun v ->
                (match v with
                | Alt (0, v) ->
                    `Str_lit (
                      trans_string_literal (Run.matcher_token v)
                    )
                | Alt (1, v) ->
                    `Id (
                      trans_identifier (Run.matcher_token v)
                    )
                | _ -> assert false
                )
              )
              v1
            ,
            Run.trans_token (Run.matcher_token v2),
            (match v3 with
            | Alt (0, v) ->
                `LF (
                  Run.trans_token (Run.matcher_token v)
                )
            | _ -> assert false
            )
            ,
            Run.opt
              (fun v -> trans_body (Run.matcher_token v))
              v4
            ,
            Run.trans_token (Run.matcher_token v5),
            (match v6 with
            | Alt (0, v) ->
                `LF (
                  Run.trans_token (Run.matcher_token v)
                )
            | _ -> assert false
            )
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_body ((kind, body) : mt) : CST.body =
  match body with
  | Children v ->
      Run.repeat1
        (fun v ->
          (match v with
          | Alt (0, v) ->
              `Attr (
                trans_attribute (Run.matcher_token v)
              )
          | Alt (1, v) ->
              `Blk (
                trans_block (Run.matcher_token v)
              )
          | Alt (2, v) ->
              `One_line_blk (
                trans_one_line_block (Run.matcher_token v)
              )
          | _ -> assert false
          )
        )
        v
  | Leaf _ -> assert false

let trans_source_file ((kind, body) : mt) : CST.source_file =
  match body with
  | Children v ->
      trans_body (Run.matcher_token v)
  | Leaf _ -> assert false

let parse_input_tree input_tree =
  let orig_root_node = Tree_sitter_parsing.root input_tree in
  let src = Tree_sitter_parsing.src input_tree in
  let errors = Run.extract_errors src orig_root_node in
  let root_node = Run.remove_extras ~extras orig_root_node in
  let matched_tree = Run.match_tree children_regexps src root_node in
  let opt_program = Option.map trans_source_file matched_tree in
  Parsing_result.create src opt_program errors

let string ?src_file contents =
  let input_tree = parse_source_string ?src_file contents in
  parse_input_tree input_tree

let file src_file =
  let input_tree = parse_source_file src_file in
  parse_input_tree input_tree

